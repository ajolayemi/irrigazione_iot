-- drop existing policy
drop policy "Superusers and company members can select" on "public"."pumps_statuses_stats";

-- drop old table
drop table "public"."pumps_statuses_stats";

-- create new table
create table
    public.pumps_switched_on (
        id bigint generated by default as identity,
        status_boolean boolean not null,
        pump_id bigint not null,
        company_id bigint not null,
        constraint pumps_switched_on_pkey primary key (id),
        constraint public_pumps_switched_on_pump_id_fkey foreign key (pump_id) references pumps (id) on update restrict on delete cascade,
        constraint public_pumps_switched_on_company_id_fkey foreign key (company_id) references companies (id) on update restrict on delete cascade
    ) tablespace pg_default;

-- enable rls
alter table "public"."pumps_switched_on" enable row level security;

-- add to realtime tables
alter publication supabase_realtime add table "public"."pumps_switched_on";


-- drop policy if it already exists
drop policy if exists "Superusers and company members can select" on public.pumps_switched_on;

-- create policy
-- for select
create policy "Superusers and company members can select" on public.pumps_switched_on as permissive for
select
    to authenticated using (
        (
            EXISTS (
                SELECT
                    1
                FROM
                    companies
                WHERE
                    (companies.id = pumps_switched_on.company_id)
            )
        )
    );



-- Create a function that keeps track of pump statuses in a separate table
CREATE
OR REPLACE FUNCTION public.track_pump_statuses () RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  -- Will hold already saved record for the pump whose status is being updated
  existing_pump_record pumps_switched_on%ROWTYPE;
BEGIN
  -- Get already saved record for the current pump
  SELECT * INTO existing_pump_record FROM pumps_switched_on WHERE pump_id = NEW.pump_id;

  -- If a record was found, meaning that a previous record was already saved in the helper table
  IF existing_pump_record is not null THEN
    -- If the current status of the pump is false
    IF NEW.status_boolean = false THEN
      -- delete existing record because this pump is no longer active
      DELETE FROM pumps_switched_on where id = existing_pump_record.id;
      -- in any other case, which should be when user is turning on a pump, do nothing
    END IF;
  ELSE
    -- When no record was found, meaning this is the first time here
    -- Insert new record
    INSERT INTO pumps_switched_on(status_boolean, pump_id, company_id) 
    VALUES (NEW.status_boolean, NEW.pump_id, NEW.company_id);
  END IF;

  RETURN NEW;
END;
$$;

