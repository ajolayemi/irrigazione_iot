-- create table
create table
    public.pumps_statuses_stats (
        id bigint generated by default as identity,
        status_boolean boolean not null,
        total_duration_in_seconds numeric not null,
        pump_id bigint not null,
        company_id bigint not null,
        constraint pumps_switched_on_pkey primary key (id),
        constraint public_pumps_switched_on_pump_id_fkey foreign key (pump_id) references pumps (id) on update restrict on delete cascade,
        constraint public_pumps_switched_on_company_id_fkey foreign key (company_id) references companies (id) on update restrict on delete cascade
    ) tablespace pg_default;

-- enable rls
alter table "public"."pumps_statuses_stats" enable row level security;

-- add to realtime tables
alter publication supabase_realtime add table "public"."pumps_statuses_stats";

-- to avoid errors when using migration files, first drop policy if it already exists
drop policy if exists "Superusers and company members can select" on public.pumps_statuses_stats;

-- create rls policy on pumps_statuses_stats table
-- for select
create policy "Superusers and company members can select" on "public"."pumps_statuses_stats" as permissive for
select
  to authenticated using (
    (
      EXISTS (
        SELECT
          1
        FROM
          companies
        WHERE
          (companies.id = pumps_statuses_stats.company_id)
      )
    )
  );


-- Create a function that calculates the seconds from the last time a pump was switched on
-- Returns 0 if the provided pump has never been switched on before
CREATE
OR REPLACE FUNCTION public.seconds_since_pump_last_switched_on (
  pump_id_input bigint,
  current_status_timestamp timestamp with time zone
) RETURNS int LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  result int;
BEGIN
  SELECT
    ROUND(
      EXTRACT(
        EPOCH
        FROM
          (current_status_timestamp - created_at)
      )
    )::int INTO result
  FROM
    pump_statuses
  WHERE
    pump_id = pump_id_input
    AND status_boolean = true
  ORDER BY
    created_at DESC
  LIMIT 1;

  IF result IS NOT NULL THEN
    RETURN result;
  ELSE
    RETURN 0;
  END IF;
END;
$$;

-- Create a function that keeps track of pump statuses in a separate table
CREATE
OR REPLACE FUNCTION public.track_pump_statuses () RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  -- Will hold already saved record for the pump whose status is being updated
  existing_pump_record pumps_statuses_stats%ROWTYPE;
  -- Will hold the duration difference in seconds between the last time a pump was switched on
  -- and now that it's being switched off
  duration_difference_in_seconds int;
BEGIN
  -- Get already saved record for the current pump
  SELECT * INTO existing_pump_record FROM pumps_statuses_stats WHERE pump_id = NEW.pump_id;

  -- Get the difference in seconds between the last time this pump was switched on and the current timestamp
  -- of when it's being switched off
  SELECT seconds_since_pump_last_switched_on(NEW.pump_id, NEW.created_at) INTO duration_difference_in_seconds;

  -- If a record was found, meaning that a previous record was already saved in the helper table
  IF existing_pump_record is not null THEN
    -- If the current status of the pump is false
    IF NEW.status_boolean = false THEN
      -- Update record
      UPDATE pumps_statuses_stats 
      SET status_boolean = NEW.status_boolean, 
          total_duration_in_seconds = existing_pump_record.total_duration_in_seconds + duration_difference_in_seconds 
      WHERE pump_id = NEW.pump_id;
    ELSE
      UPDATE pumps_statuses_stats 
      SET status_boolean = NEW.status_boolean 
      WHERE pump_id = NEW.pump_id;
    END IF;
  ELSE
    -- When no record was found, meaning this is the first time here
    -- Insert new record
    INSERT INTO pumps_statuses_stats(total_duration_in_seconds, status_boolean, pump_id, company_id) 
    VALUES (duration_difference_in_seconds, NEW.status_boolean, NEW.pump_id, NEW.company_id);
  END IF;

  RETURN NEW;
END;
$$;

-- Create trigger for each time when a new value is inserted to pump_statuses table
CREATE
OR REPLACE TRIGGER pump_statuses_insert_trigger
AFTER INSERT ON pump_statuses FOR EACH ROW
EXECUTE FUNCTION track_pump_statuses ();
