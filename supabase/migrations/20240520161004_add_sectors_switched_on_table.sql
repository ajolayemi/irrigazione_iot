-- create table
create table
    public.sectors_switched_on (
        id bigint generated by default as identity,
        status_boolean boolean not null,
        sector_id bigint not null,
        company_id bigint not null,
        constraint sectors_switched_on_pkey primary key (id),
        constraint public_sectors_switched_on_sector_id_fkey foreign key (sector_id) references sectors (id) on update restrict on delete cascade,
        constraint public_sectors_switched_on_company_id_fkey foreign key (company_id) references companies (id) on update restrict on delete cascade
    ) tablespace pg_default;

-- enable rls
alter table "public"."sectors_switched_on" enable row level security;

-- add to realtime tables
alter publication supabase_realtime add table "public"."sectors_switched_on";

-- to avoid errors when using migration files, drop existing policy before creating it again
drop policy if exists "Superusers and company members can select" on public.sectors_switched_on;

-- create rls select policy
create policy "Superusers and company members can select" on public.sectors_switched_on as permissive for
select
  to authenticated using (
    (
      EXISTS (
        SELECT
          1
        FROM
          companies
        WHERE
          (companies.id = sectors_switched_on.company_id)
      )
    )
  );


-- Create a function that keeps track of sector statuses in a separate table
CREATE
OR REPLACE FUNCTION public.track_sector_statuses () RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  -- Will hold already saved record for the sector whose status is being updated
  existing_sector_record sectors_switched_on%ROWTYPE;

  -- Will hold the id of the company this sector belongs to
  sector_company_id bigint;
BEGIN
  -- Get already saved record for the current sector
  SELECT * INTO existing_sector_record FROM sectors_switched_on WHERE sector_id = NEW.sector_id;

  -- Get the id of the company this sector belongs to
  SELECT get_sector_company_id(NEW.sector_id) into sector_company_id;

  -- If a record was found, meaning that a previous record was already saved in the helper table
  IF existing_sector_record is not null THEN
    -- If the current status of the sector is false
    IF NEW.status_boolean = false THEN
      -- delete existing record because this sector is no longer active
      DELETE FROM sectors_switched_on where id = existing_sector_record.id;
      -- in any other case, which should be when user is turning on a sector, do nothing
    END IF;
  ELSE
    -- When no record was found, meaning this is the first time here
    -- Insert new record
    INSERT INTO sectors_switched_on(status_boolean, sector_id, company_id) 
    VALUES (NEW.status_boolean, NEW.sector_id, sector_company_id);
  END IF;

  RETURN NEW;
END;
$$;

-- create trigger
CREATE
OR REPLACE TRIGGER sector_statuses_insert_trigger
AFTER INSERT ON sector_statuses FOR EACH ROW
EXECUTE FUNCTION track_sector_statuses ();
